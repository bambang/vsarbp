/* 
 * Verified SAR-BP: A verified C implementation of SAR backprojection
 * with a certified absolute error bound.
 * 
 * Version 1.0 (2015-12-04)
 * 
 * Copyright (C) 2015 Reservoir Labs Inc.
 * All rights reserved.
 * 
 * This file is free software. You can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License (GNU GPL
 * v3), or (at your option) any later version.  A verbatim copy of the
 * GNU GPL v3 is included in gpl-3.0.txt.
 * 
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See LICENSE for
 * more details about the use and redistribution of this file and the
 * whole Verified SAR-BP library.
 * 
 * This work is sponsored in part by DARPA MTO as part of the Power
 * Efficiency Revolution for Embedded Computing Technologies (PERFECT)
 * program (issued by DARPA/CMO under Contract No: HR0011-12-C-0123). The
 * views and conclusions contained in this work are those of the authors
 * and should not be interpreted as representing the official policies,
 * either expressly or implied, of the DARPA or the
 * U.S. Government. Distribution Statement "A" (Approved for Public
 * Release, Distribution Unlimited.)
 * 
 * 
 * If you are using or modifying Verified SAR-BP in your work, please
 * consider citing the following paper:
 * 
 * Tahina Ramananandro, Paul Mountcastle, Benoit Meister and Richard
 * Lethin.
 * A Unified Coq Framework for Verifying C Programs with Floating-Point
 * Computations.
 * In CPP (5th ACM/SIGPLAN conference on Certified Programs and Proofs)
 * 2016.
 * 
 * 
 * Verified SAR-BP derives from prior work listed in ACKS along with
 * their copyright and licensing information.
 * 
 * Verified SAR-BP requires third-party libraries listed in ACKS along
 * with their copyright information.
 */
/*
  Author: Benoit Meister <meister@reservoir.com>
  Author: Tahina Ramananandro <ramananandro@reservoir.com>

  C implementation of SAR backprojection with linear
  interpolation. Square root is computed in double. Sine is computed
  in double, then rounded back to single. Pulse contributions are
  computed in single-precision, but summed up in double before the
  total sum is rounded back to single. No other approximate
  optimizations are performed.

  This file is derived from
  suite/sar/kernels/ser/bp/src/sar_backprojection.c in the PERFECT
  suite (http://hpc.pnnl.gov/projects/PERFECT/).

  Kevin Barker, Thomas Benson, Dan Campbell, David Ediger, Roberto
  Gioiosa, Adolfy Hoisie, Darren Kerbyson, Joseph Manzano, Andres
  Marquez, Leon Song, Nathan R. Tallent, and Antonino Tumeo.  PERFECT
  (Power Efficiency Revolution For Embedded Computing Technologies)
  Benchmark Suite Manual. Pacific Northwest National Laboratory and
  Georgia Tech Research Institute, December 2013.
  http://hpc.pnnl.gov/projects/PERFECT/

  Copyright (c) 2014, Battelle Memorial Institute.  
  Copyright (c) 2014, Georgia Tech Research Corporation.
  All rights reserved.

  See ACKS for more information about copyright and licensing of the
  PERFECT suite.
*/
/*
The following constant values are not the actual values used by the
program.  They have been chosen to better spot the use of those
constants in the abstract syntax tree generated by Clightgen, to
replace them with Coq variables.  The actual values are specified in
SARBounds.v
*/
#define BP_NPIX_X 855
#define BP_NPIX_Y 956
#define N_RANGE_UPSAMPLED 1067
#define N_PULSES 2179

extern double sqrt(double _);
extern double sin(double _);
extern double cos(double _);

inline void norm(double *n, double x, double y, double z) {
    *n = sqrt(x*x + y*y + z*z);
}

// Input: arg
//   Output: *sine = sin(arg); *cosine = cos(arg) 
inline void sin_cos(float *sine, float *cosine, double arg) {
    *sine = (float) sin(arg);
    *cosine = (float) cos(arg);
}

void bin_sample(float * sample_r, float * sample_i, 
                float data_r[N_RANGE_UPSAMPLED],
                float data_i[N_RANGE_UPSAMPLED],
                const double * bin) {  
    const double b = *bin;
    if (b >= 0) {
	if (b < N_RANGE_UPSAMPLED-1) {
	    /* interpolation range is [bin_floor, bin_floor+1] */
	    const int bin_floor = (int) b;
	    /* interpolation weight */
	    const float w = (float) (b - (double) bin_floor);
	    /* linearly interpolate to obtain a sample at bin */
	    *sample_r = (1.0f-w)*data_r[bin_floor] + w*data_r[bin_floor+1];
	    *sample_i = (1.0f-w)*data_i[bin_floor] + w*data_i[bin_floor+1];
	    /* compute the complex exponential for the matched filter */
	    return;
	}
    }
    *sample_r = 0.0f;
    *sample_i = 0.0f;
}

void sar_backprojection2(
    float image_r[BP_NPIX_Y][BP_NPIX_X],
    float image_i[BP_NPIX_Y][BP_NPIX_X],
    float (* const data_r)[N_RANGE_UPSAMPLED],
    float (* const data_i)[N_RANGE_UPSAMPLED],
    const double platpos_x[N_PULSES],
    const double platpos_y[N_PULSES],
    const double platpos_z[N_PULSES],
    double * ku,
    double * R0,
    double * dR,
    double * dxdy,
    double * z0)
{
    const double dR_inv = 1.0/(*dR);
    const double dxdy_2 = (*dxdy) * 0x1.0p-1;
    const double ku_2 = (*ku) * 2.0;
    int p, ix, iy;

    for (iy = 0; iy < BP_NPIX_Y; ++iy)
    {
        const double py = ((double)(-BP_NPIX_Y + 1 + 2 * iy)) * dxdy_2;
        for (ix = 0; ix < BP_NPIX_X; ++ix)
        {
          const double px = ((double)(-BP_NPIX_X + 1 + 2 * ix)) * dxdy_2;

	  double contrib_r = 0.0;
	  double contrib_i = 0.0;

	  for (p = 0; p < N_PULSES; ++p)
            {
              float sample_r, sample_i, matched_filter_r, matched_filter_i, 
                prod_r, prod_i;
              double R;
              /* calculate the range R from the platform to this pixel */
              const double xdiff = platpos_x[p] - px;
              const double ydiff = platpos_y[p] - py;
              const double zdiff = platpos_z[p] - (*z0);
              double bin;
              norm(&R, xdiff, ydiff, zdiff);

              /* convert to a range bin index */
              bin = (R-(*R0))*dR_inv;
              
              bin_sample(&sample_r, &sample_i, data_r[p], data_i[p], &bin);
	      sin_cos(&matched_filter_i, &matched_filter_r, ku_2*R);

              /* scale the interpolated sample by the matched filter */
              prod_r = 
                sample_r*matched_filter_r - sample_i * matched_filter_i;
              prod_i = 
                sample_r*matched_filter_i + sample_i * matched_filter_r;
              /* accumulate this pulse's contribution into the pixel */
	      contrib_r += prod_r;
	      contrib_i += prod_i;
            }
	  image_r[iy][ix] = (float) contrib_r;
	  image_i[iy][ix] = (float) contrib_i;

        }
    }
}

// Local Variables: 
// mode: c
// c-basic-offset: 4
// End:
